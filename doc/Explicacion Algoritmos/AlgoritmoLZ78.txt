El algoritmo LZ78 es un algoritmo basado en repeticiones. En mi caso ha sido implementado a nivel de byte, por lo tanto
las repeticiones se corresponden con repeticiones de cadenas de bytes puros, tal y como estan almacenados en memoria
para el archivo a comprimir en cuestion.

La compresion es sencilla. Consiste en guardar pares de indice y byte. Donde el el indice indica la posicion en el
diccionario del antecesor del byte en una cadena de bytes. Cuando el indice es un 0, significa que no hay antecesor.

El proceso se inicia leyendo byte a byte el fichero a comprimir. Cada vez que nos encontramos con un byte nunca visto
antes, lo almacenamos en un diccionario con una referencia igual al numero cero. De este modo indicamos
que este byte no tiene antecesor, y por lo tanto es el inicio de una cadena.

En el caso de leer un byte ya visto antes, la cadena actual se debe interpretar como una pareja indice byte, donde el byte
es el ultimo leido, y el indice es la posicion de la anterior byte en el diccionario. De este modo, nosotros solo
almacenamos parejas de indices y bytes, donde cada byte es el ultimo de la cadena que forma y el indice 'apunta' a su
antecesor o nadie (= 0) si este no tiene antecesor y es el primero de su cadena.

Dada una cadena de bytes, si el prefijo completo de la cadena ya esta presente en el diccionario, solo necesitamos una
entrada para dicha cadena donde: el indice indica la posicion en el diccionario que representa el prefijo y el byte es
el que debemos concatenar a dicho prefijo par formar esta cadena.

Algoritmicamente tenemos que ir consultando al diccionario si la cadena que consideramos en cada iteracion esta "presente".
Si existe un entrada que hace referencia a una cadena A: consideraremos una nueva cadena A' que resulta de concatenar A
con el siguiente byte leido. Repetiriamos este proceso hasta que la cadena que consultamos no este presente y entonces,
simplemente debemos anadir el indice referente a la subcadena prefijo, y el ultimo byte leido. Cabe remarcar que las primeras
iteraciones de este algoritmo son ceros, debido a que el diccionario esta inicialmente vacio.

Para descomprimir la informacion, bastaria con leer el diccionario desde el principio hasta el final (en orden). Recursivamente,
pensamos en una cadena que se va formando desde la cola hasta el inicio. Mientras el indice de las entradas leidas sea
diferente de cero, vamos anadiendo los bytes de estas entradas a nuestra cadena temporal y viajando a la posicion marcada por el
indice de los pares leidos. Eventualmente llegaremos a un par con indice = 0, donde deberemos finalizar la formacion de
la cadena con el byte de esa entrada y escribir la palabra formada como texto original.